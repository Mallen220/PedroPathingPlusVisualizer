name: Build and Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to build (e.g., 'v1.6.1')"
        required: true
        default: ""

permissions:
  contents: write
  packages: write

env:
  TAG_NAME: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.tag || github.ref_name }}

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.ensure-release.outputs.upload_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install gh CLI (if missing)
        run: |
          if ! command -v gh >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y gh
          fi

      - name: Generate Release Notes
        id: generate-notes
        run: |
          # 1. Create the static portion of the notes using a Heredoc
          # This avoids the need to escape backticks or quotes
          cat > base_notes.md << 'EOF'
          ## ðŸš€ Quick Update

          Refer to the README installation section for instructions on installing or updating Pedro Pathing Plus Visualizer. Below is a condensed version of the instructions for quick reference.

          This repo is regularly updated with new features and bug fixes but tested primarily on macOS. Should an issue arise, please report it via the GitHub Issues page and revert to the previous stable version if needed.

          #### **macOS / Linux**
          Run the following command in terminal and provide your password when prompted:
          ```bash
          curl -fsSL https://raw.githubusercontent.com/Mallen220/PedroPathingPlusVisualizer/main/install.sh | bash
          ```

          #### **Windows**
          Download and install via the `.exe` installer below.

          ## ðŸ“ Release Notes
          EOF

          # 2. Extract version number (remove 'v' prefix)
          VERSION="${TAG_NAME#v}"

          # 3. Append Changelog logic
          if [ -f "CHANGELOG.md" ]; then
            # Extract section: matches "## X.Y.Z" and stops at the next "## "
            CHANGELOG_SECTION=$(awk -v version="$VERSION" '
              /^## / && p && $2 != version {exit}
              /^## / && $2 == version {p=1; next}
              p {print}
            ' CHANGELOG.md)
            
            if [ -n "$CHANGELOG_SECTION" ]; then
              echo "" >> base_notes.md
              echo "$CHANGELOG_SECTION" >> base_notes.md
            else
              echo "" >> base_notes.md
              echo "- Bug fixes and improvements" >> base_notes.md
            fi
          else
            echo "" >> base_notes.md
            echo "- Bug fixes and improvements" >> base_notes.md
          fi

          # 4. Finalize
          mv base_notes.md release-notes.md
          echo "Release notes generated."

      - name: Ensure draft release exists
        id: ensure-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e

          VERSION="${TAG_NAME#v}"
          TITLE="Pedro Pathing Plus Visualizer ${VERSION}"

          # Check for existing release
          RELEASE_JSON=$(gh release view "$TAG_NAME" --json isDraft,uploadUrl 2>/dev/null || true)

          if echo "$RELEASE_JSON" | grep -q '"isDraft": true'; then
            echo "Using existing draft release"
            UPLOAD_URL=$(echo "$RELEASE_JSON" | jq -r '.uploadUrl')
          else
            echo "Creating new draft release"
            # If triggered by tag, we don't strictly need --target, 
            # but if dispatch, use the current ref.
            gh release create "$TAG_NAME" \
              --draft \
              --title "$TITLE" \
              --notes-file release-notes.md \
              --target "${{ github.sha }}"
            
            UPLOAD_URL=$(gh release view "$TAG_NAME" --json uploadUrl | jq -r '.uploadUrl')
          fi

          echo "upload_url=$UPLOAD_URL" >> "$GITHUB_OUTPUT"

  release-mac:
    needs: prepare-release
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - run: npm ci
      - run: npm run build

      - name: Build (Mac)
        run: |
          echo "Building macOS packages..."
          npx electron-builder --mac --x64 --arm64 --publish never -c.mac.identity=null
          echo "Build complete. Checking release directory..."
          ls -la release/ || echo "release directory not found"
          find release -name "*.dmg" | head -10

      - name: Upload artifacts (Mac)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Uploading .dmg files:"
          find release -name "*.dmg" -type f | while read file; do
            echo "Uploading: $file"
            gh release upload "$TAG_NAME" "$file" --clobber || echo "Failed to upload $file"
          done

  release-win:
    needs: prepare-release
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - run: npm ci
      - run: npm run build

      - name: Decode Signing Certificate
        shell: pwsh
        env:
          MSIX_CERT_BASE64: ${{ secrets.MSIX_CERT_BASE64 }}
        run: |
          if ($env:MSIX_CERT_BASE64) {
            $pfxPath = Join-Path (Get-Location) 'msix-signing.pfx'
            [System.IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:MSIX_CERT_BASE64))
            Write-Host "Certificate decoded to $pfxPath"
          } else {
            Write-Host "No certificate found in secrets."
          }

      - name: Import Cert to Store
        shell: pwsh
        run: |
          $pfxPassword = ConvertTo-SecureString -String "${{ secrets.CSC_KEY_PASSWORD }}" -AsPlainText -Force
          Import-PfxCertificate -FilePath msix-signing.pfx -CertStoreLocation Cert:\CurrentUser\My -Password $pfxPassword

      - name: Build (Windows)
        env:
          # Note: WIN_CSC_LINK and WIN_CSC_KEY_PASSWORD are intentionally removed.
          # Electron-builder will find the cert in the Windows User Store via 'certificateSubjectName' in package.json
          MSIX_PUBLISHER: ${{ secrets.MSIX_PUBLISHER }}
          MSIX_PACKAGE_ID: ${{ secrets.MSIX_PACKAGE_ID }}
          MSIX_PUBLISHER_DISPLAY_NAME: ${{ secrets.MSIX_PUBLISHER_DISPLAY_NAME }}
        run: |
          echo "Building Windows packages..."
          npx electron-builder --win --x64 --publish never
          echo "Build complete. Checking release directory..."
          ls release/ || echo "release directory not found"
        shell: bash

      - name: Upload artifacts (Windows)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          echo "Uploading .exe, .appx, .appxupload and .msix artifacts:"
          find release -maxdepth 1 \( -name "*Setup*.exe" -o -name "*.appx" -o -name "*.appxupload" -o -name "*.msix" \) -type f | while read file; do
            echo "Uploading: $file"
            gh release upload "$TAG_NAME" "$file" --clobber || echo "Failed to upload $file"
          done

  release-linux:
    needs: prepare-release
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            libcairo2-dev \
            libpango1.0-dev \
            libjpeg-dev \
            libgif-dev \
            librsvg2-dev \
            zlib1g-dev \
            libzstd-dev

      - run: npm ci
      - run: npm run build

      - name: Build (Linux)
        run: |
          echo "Building Linux packages..."
          npx electron-builder --linux --x64 --arm64 --publish never
          echo "Build complete. Checking release directory..."
          ls -la release/ || echo "release directory not found"
          find release -name "*.AppImage" -o -name "*.deb" | head -10

      - name: Upload artifacts (Linux)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Uploading .AppImage and .deb files:"
          find release -type f \( -name "*.AppImage" -o -name "*.deb" \) | while read file; do
            echo "Uploading: $file"
            gh release upload "$TAG_NAME" "$file" --clobber || echo "Failed to upload $file"
          done
